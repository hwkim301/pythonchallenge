# Level 7 

This time an image named [oxygen](/7/oxygen.png) is given. 


The HTML title for level7 is `smarty`. Wonder the title is going to help solve this level. 


Unlike the previous level there aren't any more hints in the page source. 


I'm guessing the image is the most important hint.


First I ran `file` on the image. It's good practice to check the contents of a file using `file`

```bash 
file oxygen.png 
oxygen.png: PNG image data, 629 x 95, 8-bit/color RGBA, non-interlaced
```


Nothing much, it's just an image file, but if you zoom in and look carefully at the image file you can see there's a [grey strip](/7/grey_strip.png) of pixels right in the middle.


When examining pixels in an image file Python provides you a module name `PIL` but since `PIL` hasn't been updated since 2009 people made a fork of `PIL` named [PILLOW](https://pillow.readthedocs.io/en/stable/).

`PILLOW` is not a built-in module to use it you need to install it via `pip`.


```python
pip install pillow
```


**[PILLOW](https://pillow.readthedocs.io/en/stable/)** is actively in development and maintained by many people so  we'll use it to solve this level. You'll have to use the `PILLOW` module whenever there's a level that doesn't have any hints other than the image so heads up.


You can use the `with open` to open files using the `Image.open` method for image files as well.


```python
from PIL import Image 

with Image.open('oxygen.png') as img:
    img.show()

w,h=img.height,img.width
print(w,h)
print(img.size)
```

When you use `PIL` you usually import the `Image` module. The `Image` module handles literally the images.

You can open an image file via [Image.open](https://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.open) and view it using [Image.show](https://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.Image.show).


You can also grab the height, and width using [Image.height](https://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.Image.height) and [Image.width](https://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.Image.width) both return the value in `int` respectively. 


For us we need to find the pixel values of the `grey strip` in the image because that's the part where it's a bit odd and different from the everyday images we encounter.


Another interesting point was that the `grey strip` is exactly at the middle of the height.


The height of the image is `95` so half of the height would be `47`. We only want the **int** part. 

[`Image.getpixel`](https://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.Image.getpixel)** returns you the pixel value at a certain position.  

```python
from PIL import Image

with Image.open("oxygen.png") as img:

    w, h = img.width, img.height

    y = h // 2
    for x in range(w):
        rgb = img.getpixel((x, y))
        print(f"pixel at {x},{y},{rgb}")
```


The result is [this](/7/pixels)


I brought a couple of the `rgb` values. Strangely the values for `r,g,b` are the same. It also repeats `5 ~ 7` times.


``` python 
(115, 115, 115, 255)
(115, 115, 115, 255)
(115, 115, 115, 255)
(115, 115, 115, 255)
(115, 115, 115, 255)
(109, 109, 109, 255)
(109, 109, 109, 255)
(109, 109, 109, 255)
(109, 109, 109, 255)
(109, 109, 109, 255)
(109, 109, 109, 255)
(109, 109, 109, 255)
(97, 97, 97, 255)
(97, 97, 97, 255)
(97, 97, 97, 255)
(97, 97, 97, 255)
(97, 97, 97, 255)
(97, 97, 97, 255)
(97, 97, 97, 255)
(114, 114, 114, 255)
(114, 114, 114, 255)
(114, 114, 114, 255)
(114, 114, 114, 255)
(114, 114, 114, 255)
(114, 114, 114, 255)
(114, 114, 114, 255)
...
```


If you look up the rgb values [here](https://www.rapidtables.com/web/color/RGB_Color.html) repeated ex) `(115, 115, 115, 255)`, `(109, 109, 109, 255), (97,97,97,255)` all the values are `grey`.


Another interesting fact is that all the pixels that have the same `rgb` values are repeated `7` times except `(115, 115, 115, 255)`.


```python
from PIL import Image

with Image.open("oxygen.png") as img:

    w, h = img.width, img.height
    pixels=[]
    y = h // 2
    for x in range(w):
        rgb = img.getpixel((x, y))
        print(f"{rgb}")
        r,g,b,a=rgb 
        if r==g==b:
            pixels.append(rgb)

print(*pixels)
```

I tried to select the `r,g,b,a` values only once if the r value and g value and b value were equal. You can achieve this by using slicing. 

Slicing by 7 `[::7]` only selects the elements which are the start of the duplicate `r,g,b` values.


The result is this. 


```python
[(115, 115, 115, 255), (109, 109, 109, 255), (97, 97, 97, 255), (114, 114, 114, 255), (116, 116, 116, 255), (32, 32, 32, 255), (103, 103, 103, 255), (117, 117, 117, 255), (121, 121, 121, 255), (44, 44, 44, 255), (32, 32, 32, 255), (121, 121, 121, 255), (111, 111, 111, 255), (117, 117, 117, 255), (32, 32, 32, 255), (109, 109, 109, 255), (97, 97, 97, 255), (100, 100, 100, 255), (101, 101, 101, 255), (32, 32, 32, 255), (105, 105, 105, 255), (116, 116, 116, 255), (46, 46, 46, 255), (32, 32, 32, 255), (116, 116, 116, 255), (104, 104, 104, 255), (101, 101, 101, 255), (32, 32, 32, 255), (110, 110, 110, 255), (101, 101, 101, 255), (120, 120, 120, 255), (116, 116, 116, 255), (32, 32, 32, 255), (108, 108, 108, 255), (101, 101, 101, 255), (118, 118, 118, 255), (101, 101, 101, 255), (108, 108, 108, 255), (32, 32, 32, 255), (105, 105, 105, 255), (115, 115, 115, 255), (32, 32, 32, 255), (91, 91, 91, 255), (49, 49, 49, 255), (48, 48, 48, 255), (53, 53, 53, 255), (44, 44, 44, 255), (32, 32, 32, 255), (49, 49, 49, 255), (49, 49, 49, 255), (48, 48, 48, 255), (44, 44, 44, 255), (32, 32, 32, 255), (49, 49, 49, 255), (49, 49, 49, 255), (54, 54, 54, 255), (44, 44, 44, 255), (32, 32, 32, 255), (49, 49, 49, 255), (48, 48, 48, 255), (49, 49, 49, 255), (44, 44, 44, 255), (32, 32, 32, 255), (49, 49, 49, 255), (48, 48, 48, 255), (51, 51, 51, 255), (44, 44, 44, 255), (32, 32, 32, 255), (49, 49, 49, 255), (49, 49, 49, 255), (52, 52, 52, 255), (44, 44, 44, 255), (32, 32, 32, 255), (49, 49, 49, 255), (48, 48, 48, 255), (53, 53, 53, 255), (44, 44, 44, 255), (32, 32, 32, 255), (49, 49, 49, 255), (49, 49, 49, 255), (54, 54, 54, 255), (44, 44, 44, 255), (32, 32, 32, 255), (49, 49, 49, 255), (50, 50, 50, 255), (49, 49, 49, 255), (93, 93, 93, 255)]
```


Odd it still has the same `r,g,b` values in the tuple list. 


We can write a list comprehension to select only the unique values which would be `r`.


```python
duplicates=[(115, 115, 115, 255), (109, 109, 109, 255), (97, 97, 97, 255), (114, 114, 114, 255), (116, 116, 116, 255), (32, 32, 32, 255), (103, 103, 103, 255), (117, 117, 117, 255), (121, 121, 121, 255), (44, 44, 44, 255), (32, 32, 32, 255), (121, 121, 121, 255), (111, 111, 111, 255), (117, 117, 117, 255), (32, 32, 32, 255), (109, 109, 109, 255), (97, 97, 97, 255), (100, 100, 100, 255), (101, 101, 101, 255), (32, 32, 32, 255), (105, 105, 105, 255), (116, 116, 116, 255), (46, 46, 46, 255), (32, 32, 32, 255), (116, 116, 116, 255), (104, 104, 104, 255), (101, 101, 101, 255), (32, 32, 32, 255), (110, 110, 110, 255), (101, 101, 101, 255), (120, 120, 120, 255), (116, 116, 116, 255), (32, 32, 32, 255), (108, 108, 108, 255), (101, 101, 101, 255), (118, 118, 118, 255), (101, 101, 101, 255), (108, 108, 108, 255), (32, 32, 32, 255), (105, 105, 105, 255), (115, 115, 115, 255), (32, 32, 32, 255), (91, 91, 91, 255), (49, 49, 49, 255), (48, 48, 48, 255), (53, 53, 53, 255), (44, 44, 44, 255), (32, 32, 32, 255), (49, 49, 49, 255), (49, 49, 49, 255), (48, 48, 48, 255), (44, 44, 44, 255), (32, 32, 32, 255), (49, 49, 49, 255), (49, 49, 49, 255), (54, 54, 54, 255), (44, 44, 44, 255), (32, 32, 32, 255), (49, 49, 49, 255), (48, 48, 48, 255), (49, 49, 49, 255), (44, 44, 44, 255), (32, 32, 32, 255), (49, 49, 49, 255), (48, 48, 48, 255), (51, 51, 51, 255), (44, 44, 44, 255), (32, 32, 32, 255), (49, 49, 49, 255), (49, 49, 49, 255), (52, 52, 52, 255), (44, 44, 44, 255), (32, 32, 32, 255), (49, 49, 49, 255), (48, 48, 48, 255), (53, 53, 53, 255), (44, 44, 44, 255), (32, 32, 32, 255), (49, 49, 49, 255), (49, 49, 49, 255), (54, 54, 54, 255), (44, 44, 44, 255), (32, 32, 32, 255), (49, 49, 49, 255), (50, 50, 50, 255), (49, 49, 49, 255), (93, 93, 93, 255)]


unique=[r for r,g,b,a in duplicates if r==g==b]

print(unique)

[115, 109, 97, 114, 116, 32, 103, 117, 121, 44, 32, 121, 111, 117, 32, 109, 97, 100, 101, 32, 105, 116, 46, 32, 116, 104, 101, 32, 110, 101, 120, 116, 32, 108, 101, 118, 101, 108, 32, 105, 115, 32, 91, 49, 48, 53, 44, 32, 49, 49, 48, 44, 32, 49, 49, 54, 44, 32, 49, 48, 49, 44, 32, 49, 48, 51, 44, 32, 49, 49, 52, 44, 32, 49, 48, 53, 44, 32, 49, 49, 54, 44, 32, 49, 50, 49, 93]

```

All the elements in the unique values seem to be in the **ASCII** range which is 0~127


Python [bytes](https://docs.python.org/3/library/stdtypes.html#bytes) class convert iterables of **int**s  to a byte-string. `bytes` expects the integers to be in the range of `0~255`. 


Most people would convert an iterable of `int`s to string using a `for` loops and a `chr` but I recommend using the built-in class `bytes` it's a much more neat and pythonic way to write code. 

```python
unique=[115, 109, 97, 114, 116, 32, 103, 117, 121, 44, 32, 121, 111, 117, 32, 109, 97, 100, 101, 32, 105, 116, 46, 32, 116, 104, 101, 32, 110, 101, 120, 116, 32, 108, 101, 118, 101, 108, 32, 105, 115, 32, 91, 49, 48, 53, 44, 32, 49, 49, 48, 44, 32, 49, 49, 54, 44, 32, 49, 48, 49, 44, 32, 49, 48, 51, 44, 32, 49, 49, 52, 44, 32, 49, 48, 53, 44, 32, 49, 49, 54, 44, 32, 49, 50, 49, 93]

answer=bytes(unique)
print(answer)

b'smart guy, you made it. the next level is [105, 110, 116, 101, 103, 114, 105, 116, 121]'
```


It looks like we're almost on to the next level. Just need to do the conversion once more with `[105, 110, 116, 101, 103, 114, 105, 116, 121]` 


Using [Ipython](https://ipython.org/) is a good choice when you want to write short code, don't want to save it to a `.py` file and just want the immediate result of a statement. 


```python
bytes([105, 110, 116, 101, 103, 114, 105, 116, 121])
b'integrity'
```


Changing the URL from http://www.pythonchallenge.com/pc/def/oxygen.html to http://www.pythonchallenge.com/pc/def/integrity.html takes you to level8.