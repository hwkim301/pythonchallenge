# Level19 

An image named **[map](/19/map.jpg)** is given. 


The image which is a map kind of resembles India to me. 


The title of HTML is `please!`.


In the page source there's also some comments.


```html
<!--
From: leopold.moz@pythonchallenge.com
Subject: what do you mean by "open the attachment?"
Mime-version: 1.0
Content-type: Multipart/mixed; boundary="===============1295515792=="

It is so much easier for you, youngsters.
Maybe my computer is out of order.
I have a real work to do and I must know what's inside!

--===============1295515792==
Content-type: audio/x-wav; name="indian.wav"
Content-transfer-encoding: base64
```


Below are some base64 encoded data as well.


```
UklGRvyzAQBXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YdizAQBABkAMQAtAAEADQAJA
BEAEQAJAAkAGQAVABUAEQApAC0AJQAhAD0APQANADUAFQAVAD0AEQA5ADUAGQAlAAj8PQAVABkAE
QAJACUAFQAQ/CkAKQAg/BEAMQAo/AEABQANABEAAPw1ADEAOPwZADkAHPwBADj8OQAhABT8IQARA
AD8FQAQ/Dz8AQA8/BEAGQAQ/DkAIQBA/B0AMQAU/BEAOPwo/DkAMPw1AC0AFPwhAC0AIQA0/AD8J
...
```


Since we already solved level2 and level3 using regex. let's do it again. 


```python
import requests
import re

res = requests.get("http://www.pythonchallenge.com/pc/hex/bin.html", auth=("butter", "fly"))
boundary = re.escape(r"--===============1295515792==")
pattern = re.compile(f"{boundary}(.*?){boundary}", re.DOTALL)
match = pattern.search(res.text).group(1).strip("\n")
```


I used **[re.escape](https://docs.python.org/3/library/re.html#re.escape)** because regex interprets `-` as a range but since we don't want that we need to escape it. 


**[re.compile](https://docs.python.org/3/library/re.html#re.compile)** allows you to compile regex expressions. Compiling regex expressions is useful when you need to use the regular expression multiple times. 


**[re.search](https://docs.python.org/3/library/re.html#re.search)** scans the entire string for a match. In our code we will used the regex expression compiled to search what we want in `res.text`. 


**[group](https://docs.python.org/3/library/re.html#re.Match.group)** returns one or more subgroups of the match. Since we want the second group where base64-encoded data is bounded by `"--===============1295515792=="`, I used `group(1)`. If not using `group(1)` it will return the whole match which isn't what we want. 


Running the code gives us the following output. 


```
Content-type: audio/x-wav; name="indian.wav"
Content-transfer-encoding: base64

UklGRvyzAQBXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YdizAQBABkAMQAtAAEADQAJA
BEAEQAJAAkAGQAVABUAEQApAC0AJQAhAD0APQANADUAFQAVAD0AEQA5ADUAGQAlAAj8PQAVABkAE
QAJACUAFQAQ/CkAKQAg/BEAMQAo/AEABQANABEAAPw1ADEAOPwZADkAHPwBADj8OQAhABT8IQARA
...
```


It looks like it selected the base64-encoded data but also the Content-type and Content-transfer-encoding which we don't want. 


I need to get rid of the first `3` lines which are the Content-type and Content-transfer-encoding. **[str.splitlines](https://docs.python.org/3/library/stdtypes.html#str.splitlines)** splits strings into lists using `'\n'` usually as the boundary. Then slicing it will select only the base64-encoded data. 


I also used `strip` to get rid of any newlines because there are a couple of newlines in the base64-encoded data. 


You also need to save it as bytes because base64-encoded data are bytes.


```python
with open("blob","wb") as f:
    clean="".join(match.splitlines()[3:]).strip("\n").encode("utf-8")
    f.write(clean)
```


The HTML comment indicated that the data was `Content-type: audio/x-wav; name="indian.wav"` an wav file so I decoded the base64-encoded data to a wav file using nested with statements.


```python
with open("india.wav","wb") as file:
    with open("blob","rb") as f:
        mess=f.read()
    file.write(b64decode(mess))
```

It is an actual wav file.


```bash
file india.wav 
india.wav: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 11025 Hz
```


Let's check the india.wav file out.


<audio controls>
    <source src=">