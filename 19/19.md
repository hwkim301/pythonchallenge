# Level19 

An image named **[map](/19/map.jpg)** is given. 


The image which is a map kind of resembles India to me. 


The title of HTML is `please!`.


In the page source there's also some comments.


```html
<!--
From: leopold.moz@pythonchallenge.com
Subject: what do you mean by "open the attachment?"
Mime-version: 1.0
Content-type: Multipart/mixed; boundary="===============1295515792=="

It is so much easier for you, youngsters.
Maybe my computer is out of order.
I have a real work to do and I must know what's inside!

--===============1295515792==
Content-type: audio/x-wav; name="indian.wav"
Content-transfer-encoding: base64
```


Below are some base64 encoded data as well.


```
UklGRvyzAQBXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YdizAQBABkAMQAtAAEADQAJA
BEAEQAJAAkAGQAVABUAEQApAC0AJQAhAD0APQANADUAFQAVAD0AEQA5ADUAGQAlAAj8PQAVABkAE
QAJACUAFQAQ/CkAKQAg/BEAMQAo/AEABQANABEAAPw1ADEAOPwZADkAHPwBADj8OQAhABT8IQARA
AD8FQAQ/Dz8AQA8/BEAGQAQ/DkAIQBA/B0AMQAU/BEAOPwo/DkAMPw1AC0AFPwhAC0AIQA0/AD8J
...
```


Since we already solved level2 and level3 using regex. let's do it again. 


```python
import requests
import re

res = requests.get("http://www.pythonchallenge.com/pc/hex/bin.html", auth=("butter", "fly"))
boundary = re.escape(r"--===============1295515792==")
pattern = re.compile(f"{boundary}(.*?){boundary}", re.DOTALL)
match = pattern.search(res.text).group(1).strip("\n")
```


I used **[re.escape](https://docs.python.org/3/library/re.html#re.escape)** because regex interprets `-` as a range but since we don't want that we need to escape it. 


**[re.compile](https://docs.python.org/3/library/re.html#re.compile)** allows you to compile regex expressions. Compiling regex expressions is useful when you need to use the regular expression multiple times. 


**[re.search](https://docs.python.org/3/library/re.html#re.search)** scans the entire string for a match. In our code we will used the regex expression compiled to search what we want in `res.text`. 


**[group](https://docs.python.org/3/library/re.html#re.Match.group)** returns one or more subgroups of the match. Since we want the second group where base64-encoded data is bounded by `"--===============1295515792=="`, I used `group(1)`. If not using `group(1)` it will return the whole match which isn't what we want. 


Running the code gives us the following output. 


```
Content-type: audio/x-wav; name="indian.wav"
Content-transfer-encoding: base64

UklGRvyzAQBXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YdizAQBABkAMQAtAAEADQAJA
BEAEQAJAAkAGQAVABUAEQApAC0AJQAhAD0APQANADUAFQAVAD0AEQA5ADUAGQAlAAj8PQAVABkAE
QAJACUAFQAQ/CkAKQAg/BEAMQAo/AEABQANABEAAPw1ADEAOPwZADkAHPwBADj8OQAhABT8IQARA
...
```


It looks like it selected the base64-encoded data but also the Content-type and Content-transfer-encoding which we don't want. 


I need to get rid of the first `3` lines which are the Content-type and Content-transfer-encoding. **[str.splitlines](https://docs.python.org/3/library/stdtypes.html#str.splitlines)** splits strings into lists using `'\n'` usually as the boundary. Then slicing it will select only the base64-encoded data. 


I also used `strip` to get rid of any newlines because there are a couple of newlines in the base64-encoded data. 


You also need to save it as bytes because base64-encoded data are bytes.


```python
with open("blob","wb") as f:
    clean="".join(match.splitlines()[3:]).strip("\n").encode("utf-8")
    f.write(clean)
```


The HTML comment indicated that the data was `Content-type: audio/x-wav; name="indian.wav"` an wav file so I decoded the base64-encoded data to a wav file using nested with statements.


```python
with open("india.wav","wb") as file:
    with open("blob","rb") as f:
        mess=f.read()
    file.write(b64decode(mess))
```

It is an actual wav file.


```bash
file india.wav 
india.wav: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 11025 Hz
```


Let's check the india.wav file out.


It says **sorry**.


Changing the URL to http://www.butter:fly@pythonchallenge.com/pc/hex/sorry.html shows this.


```
- "what are you apologizing for?"
```

So sorry isn't the answer. 


Let's go back to the [image](/19/map.jpg).


By convention maps are drawn like **[this](https://c8.alamy.com/comp/2SY06WF/illustration-andhra-pradesh-location-map-india-asia-2SY06WF.jpg)**, usually the sea is colored blue and the land is colored in green, brown or etc, but our image is colored in the opposite way. 


The land is blue and the sea is brown, it's also the map of India. 


I'm taking a wild guess but maybe the level wants us to change the endianness. Maybe it's a pun on India, it does sound similar to **[endianness](https://en.wikipedia.org/wiki/Endianness)**.


Little-endian is predominantly used x86(Windows...), ARM(Macbooks...) ...etc


```bash
file india.wav 
india.wav: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 11025 Hz
```


The wav file is little-endian. Let's try to change it to big-endian.


There are many ways to change a little-endian wav file to a big-endian wav file.


I think the level wants us to use the built-in **[wave](https://docs.python.org/3/library/wave.html)** module, but I found it to be a bit clunky. 


Instead you can install the **[soundfile](https://python-soundfile.readthedocs.io/en/0.13.1/#)** module via pip.


I used [soundfile.read](https://python-soundfile.readthedocs.io/en/0.13.1/#soundfile.read) to read the wav file, it returns a tuple. 


data the `soundfile.read` returned is a NumPy array that contains the actual audio samples you can think of it has the actual audio. 
samplerate the `soundfile.read`returned is an integer that represents the sampling rate of the audio file. 


[soundfile.write](https://python-soundfile.readthedocs.io/en/0.13.1/#soundfile.write) writes data to a soundfile. The **[soundfile.SoundFile](https://python-soundfile.readthedocs.io/en/0.13.1/#soundfile.SoundFile)** has a **endian** keyword which let's us select the endianness we want we can use that and the `soundfile.write` function to change the endianness of the wav file.


The code that does just that is below.

```python
data,samplerate=soundfile.read("india.wav")
soundfile.write("new.wav",data,samplerate,endian="big")
```


Let's play the wav file that uses big-endian. 


It says `You are an idiot hahahahaha!`, so the answer seems to be **idiot**.


Changing the url to **[idiot](http://www.pythonchallenge.com/pc/hex/idiot.html)** shows a picture of **[leo](/19/leopold.jpg)** who is Mozart's dad.


Let's click once more and here is level 20. http://www.butter:fly@pythonchallenge.com/pc/hex/idiot2.html. 