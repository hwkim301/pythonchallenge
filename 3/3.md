# Level3 

This time A picture of a [candle](/3/bodyguard.jpg) is given. 


The HTML title is re and the picture given is named bodyguard.jpg. 


From the title it looks like I'm probably going to have to use the re module.


Beneath the picture there's also a sentence. It says **One small letter, surrounded by EXACTLY three big bodyguards on each of its sides.**


When looking at the page source there's a whole bunch of text. 
Using the sentence above it looks like you need to find the answer. 


I don't think I've mentioned it before but you should always check the page source. 


To get the whole bunch of text in the page source we can use the code from the previous level.


Since there is only one `<!-- -->"` HTML comment tag we don't need to use `[-1]` to select the mess. 


We still need to use `re.DOTALL` because the mess that we need to scrape from the page source consists of multiple lines. 


Go back to the sentence **One small letter, surrounded by EXACTLY three big bodyguards on each of its sides.** and look at the picture. 

This part tells us which kind of regex we need to make. 

We need to make a regex that starts with 3 capital letters and then a lowercase letter and then 3 capital letters.

Keeping that in mind I wrote regex like this `[A-Z]{3}([a-z])[A-Z]{3}`

It needs to start with 3 capital letters, then a lower case and 3 capital letters at the end. 


```python
import requests
import re

res = requests.get("http://www.pythonchallenge.com/pc/def/equality.html")
boundary = r"<!--(.*?)-->"

mess = ''.join(re.findall(boundary, res.text,re.DOTALL))
answer=re.findall(r'[A-Z]{3}([a-z])[A-Z]{3}',mess)
print(answer)
```

It return a whole bunch of letters with `j` being the first one. 


That led me inspecting the first `j` that matched the pattern we wanted. Which was `xZWDZjUZM`
It did match the fact that there was 3 capital letters and then a lower case which was `j` and had 3 capital letter respectively `U,Z,M`


The unexpected part was that there was an extra Z at the beginning which meant that our lowercase had 4 capital letters in front of it. 


We need exactly three capital letters. That let me to change the regex. 


`[A-Z]{3}([a-z])[A-Z]{3}` returned a lowercase that had 4 capital letters at the end. How can I fix the regex so it only gets lowercases that have 3 capital letters in front of it and after it? 


You need to think outside of the box and change the regex and include a condition where you can't put a capital in front of the 3 capital letters in front or behind the lowercase that we want. 

Here's the final regex **[^A-Z][A-Z]{3}([a-z])[A-Z]{3}[^A-Z]**


Putting an anchor(^) in the range([]) doesn't allow characters in the character set. 


I used `''.join()` on `re.findall()` because `re.findall()` returns a `list` but I need that list as a string. 
It needs to be a string because I'm trying to use that string with `re.findall()` again to lowercase characters that I want.


Changing the URL from http://www.pythonchallenge.com/pc/def/equality.html to http://www.pythonchallenge.com/pc/def/linkedlist.html takes you to level4.

