# Level 1 

The URL for level1 changed from `274877906944.html` to (http://www.pythonchallenge.com/pc/def/map.html).

As I said previously for it's good practice to check the HTML title first.

The HTML title for level1 is *What about making trans?* 

Moving your cursor to the tab will show it the HTML title. 
You can also view it as a HTML tag by right clicking and Inspect.

I'm also given an image [map.jpg](/1/map.jpg).
It's a notebook that has `K->M, O->Q, E->G` written on it.

There's also a [ciphertext](/1/level1_hints.png).

If you look carefully shifting *2 alphabets* from K gets you M, O gets you Q, E gets you G. 


K,L,M 
O,P,Q 
E,F,G 

That means shifting 2 characters from our ciphertext `g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj.` will likely gives us the decipher.

There is a famous substitution cipher called [*Caesar_cipher*](https://en.wikipedia.org/wiki/Caesar_cipher) that's similar to the problem in level1.
The only difference beteween Caesar cipher and the problem in level1 is that Caesar Cipher shifts 3 letters instead of 2. 

Another famous substitution cipher called [ROT13](https://en.wikipedia.org/wiki/ROT13) is famous. 
ROT13 shifts 13 lettters as it says in the name. 


```python
import string 
letters = string.ascii_lowercase

def dec(cipher):
    decrypt = []
    for c in cipher:
        if c in letters:
            decrypt.append(chr((ord(c) - ord("a") + 2) % 26 + 97))
        else:
            decrypt.append(c)
    return "".join(decrypt)
```

The `dec` function gets each character's ASCII value and subtracts a to get the index of the alphabet and adds `2`. this gives us the offset(how far it is away from a) and takes the remainder of it divided by `26`. you need to divide it by 26 because there are only 26 letters in the alphabets. 
`97` is the ASCII value for `'a'` so by adding the offset with `97` gives you the actual letters.


I initially wrote the `dec` function commented out. Many people say string concatenation is generally bad practice in Python. 
Especially if the string is long. 
Reading [this](https://stackoverflow.com/questions/39675898/is-python-string-concatenation-bad-practice) post will give an detailed explanation.

According to the post string concatenation is fine if the string is short but using `''.join()` is the better choice so I went with that. 


Running `1.py` gives us the decipher. 

The decipher looks like this 

*i hope you didnt translate it by hand. thats what computers are for. doing it in by hand is inefficient and that's why this text is so long. using string.maketrans() is recommended. now apply on the url*

The decipher tells me to use `string.maketrans()` but because I've never used `string.maketrans()` I decided not to. 

Since the URL for level1 is (http://www.pythonchallenge.com/pc/def/map.html) I should do the 2 letter shift on the word *map*. 

Passing the string `map` to `1.py` gives you `ocr`. 

Changing the URL from (http://www.pythonchallenge.com/pc/def/map.html) to (http://www.pythonchallenge.com/pc/def/ocr.html) gets you to level2.  


P.S you can also do this using shellscript 

```bash
echo "g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj." | tr a-z c-za-x
```


If the letter is between `a-x` you can `2` letter shift it to `c-z`, but if the letter is `y` or `z` it needs to go back to `a` or `b` so the letters are changed rom all the letters except `y`,`z` where the original letters are. 
That's why you need the extra `a-x` after `c-z`.  