# Level 10 

A picture of a bull is given [bull](/10/bull.jpg).

The HTML title is `what are you looking at?`. 

Below The picture **`len(a[30]) =?`** is written.


Finding `len(a[30])` is likely to be the answer. 


A link is in the page source <a href="sequence.txt">


Following the [link](http://www.pythonchallenge.com/pc/return/sequence.txt) shows you the list `a`.


```
a = [1, 11, 21, 1211, 111221, 
```


The numbers in the list `a` seems like some sort of sequence but I don't know what it is. 


so I googled it and google showed a lot of **[look-and-say sequence](https://en.wikipedia.org/wiki/Look-and-say_sequence)** related results.


The look-and-say sequence literally generates the next value by looking at the previous value and reading it out loud.


You'll probably understand how the look-and-say sequence generates the next value right away.


a[0]= 1 
a[1]= 11 (one 1)
a[2]= 21 (two 1) when reading a[1]
a[3]= 1211 (one 2 one 1) when reading a[2]
a[4]= 111221 (one 1 one 2 two 1 two 1) when reading a[3]
...


You can write naive code by checking how many times the same number occurs and count them and add them in front of the number.
You need to `type-cast` the occurrence of the same number by using `str`.


I got **[this](https://www.geeksforgeeks.org/look-and-say-sequence/)** from geekforgeeks. shout out to those guys


Counting the same numbers appearance is done by the `if` statement.


```python
if curr[j]==curr[j-1]:
```

If the previous number is different from the current number the `else` statement counts the numbers that were same and adds the previous number(the number that was the same) and sets the count back to 1 to count how many times the next number is repeated.


```python
else:
    nextstr+=str(cnt)+curr[j-1]
    cnt=1
```

The final part of the function checks the last group. `cnt` counts the times how many times the last number occurs and `curr[-1]` selects the last number.
`curr` then gets update to the `nextstr` which is the final answer. 


```python
   nextstr+=str(cnt)+curr[-1]
        curr=nextstr
```


```python
def look_and_say(n):
    if n==1:
        return "1"
    
    curr="1"

    for i in range(2,n+1):
        nextstr=""
        cnt=1

        for j in range(1,len(curr)):

            if curr[j]==curr[j-1]:
                cnt+=1
            
            else:
                nextstr+=str(cnt)+curr[j-1]
                cnt=1
        
        nextstr+=str(cnt)+curr[-1]
        curr=nextstr


    return curr
```

since `a[30]` is the `31st` value in the look-and-say sequence passing `31` to the function gives you `5808` which is the answer. 

```python
print(len(look_and_say(31)))
5808
```

Instead of righting a naive solution which is perfect I decided to search google if there were some more pythonic solutions.

`yen223` from https://www.reddit.com/r/programminghorror/comments/8o5kfq/solution_to_a_looksay_sequence_generator/ wrote this amazing code.

```python
from itertools import groupby

def look_and_say(s):
    return "".join(f"{len(list(x))}{n}" for n, x in groupby(s))

sequence='1'
for _ in range(30):
    sequence=look_and_say(sequence)
print(len(sequence))
```

Python's **[itertools](https://docs.python.org/3/library/itertools.html)** module has an **[groupby](https://docs.python.org/3/library/itertools.html#itertools.groupby)** function that returns consecutive keys(how many times a certain value is repeated) and groups (a value).


`n` is the character that is being grouped `1`, `2`, `3` and `x` is the iterator(the function that generates the next value in the look-and-say sequence) so `len(x)` returns how many times a certain number is repeated. 


To change a `list` to a `str` the you use **[str.join]**(https://docs.python.org/3/library/stdtypes.html#str.join).


Not to get confused **join** is a `str` method not a `list` method. You usually pass an **iterable** as the argument for `str`


`Pi Marillion` wrote another awesome code as well [here](https://stackoverflow.com/questions/71897929/the-look-and-say-sequence-is-the-sequence)

```python
from itertools import groupby


def look_and_say(line):
    sequence = groupby(line)
    return "".join(f"{sum(1 for _ in i)}{char}" for char, i in sequence)


line = "1"
for _ in range(30):
    (line := look_and_say(line))

print(len(line))
```


It's similar to the code before but `Pi Marillion` uses `sum` to count the repeated numbers and the **[walrus operator](https://docs.python.org/3/whatsnew/3.8.html#assignment-expressions)**.


Changing the URL from http://www.huge:file@pythonchallenge.com/pc/return/bull.html to http://www.huge:file@pythonchallenge.com/pc/return/5808.html takes you to the level 11.